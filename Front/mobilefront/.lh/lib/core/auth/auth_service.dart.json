{
    "sourceFile": "lib/core/auth/auth_service.dart",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 2,
            "patches": [
                {
                    "date": 1745536421670,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1745536437369,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,6 +1,7 @@\n // lib/core/auth/auth_service.dart\r\n import 'package:flutter/foundation.dart'; // For ChangeNotifier\r\n+import 'package:flutter/material.dart';\r\n import 'package:flutter_appauth/flutter_appauth.dart';\r\n import 'package:jwt_decoder/jwt_decoder.dart';\r\n import 'package:http/http.dart' as http; // For logout if needed\r\n \r\n"
                },
                {
                    "date": 1745538031900,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -87,9 +87,8 @@\n           AuthConfig.clientId,\r\n           AuthConfig.redirectUri,\r\n           issuer: AuthConfig.issuer,\r\n           scopes: AuthConfig.scopes,\r\n-\r\n           preferEphemeralSession: false, // Set to true to not store cookies in browser\r\n           additionalParameters: AuthConfig.customParameters, // Pass audience here if needed\r\n         ),\r\n       );\r\n"
                }
            ],
            "date": 1745536421670,
            "name": "Commit-0",
            "content": "// lib/core/auth/auth_service.dart\r\nimport 'package:flutter/foundation.dart'; // For ChangeNotifier\r\nimport 'package:flutter_appauth/flutter_appauth.dart';\r\nimport 'package:jwt_decoder/jwt_decoder.dart';\r\nimport 'package:http/http.dart' as http; // For logout if needed\r\n\r\nimport 'auth_config.dart';\r\nimport '../storage/secure_storage_service.dart';\r\n\r\nclass AuthService with ChangeNotifier {\r\n  final FlutterAppAuth _appAuth = const FlutterAppAuth();\r\n  final SecureStorageService _storageService = SecureStorageService();\r\n\r\n  String? _accessToken;\r\n  String? _idToken;\r\n  String? _refreshToken;\r\n  DateTime? _accessTokenExpiration;\r\n  Map<String, dynamic>? _idTokenClaims;\r\n  bool _isAuthenticated = false;\r\n  bool _isLoading = false;\r\n\r\n  // --- Storage Keys ---\r\n  static const String _accessTokenKey = 'access_token';\r\n  static const String _idTokenKey = 'id_token';\r\n  static const String _refreshTokenKey = 'refresh_token';\r\n  static const String _accessTokenExpirationKey = 'access_token_expiration';\r\n\r\n  // --- Getters ---\r\n  bool get isAuthenticated => _isAuthenticated;\r\n  bool get isLoading => _isLoading;\r\n  String? get accessToken => _accessToken;\r\n  Map<String, dynamic>? get userClaims => _idTokenClaims;\r\n\r\n  AuthService() {\r\n    // Try to load tokens on startup\r\n    _loadTokensFromStorage();\r\n  }\r\n\r\n  Future<void> _setLoading(bool value) async {\r\n     // Use WidgetsBinding.instance.addPostFrameCallback to avoid setState errors during build\r\n    WidgetsBinding.instance.addPostFrameCallback((_) {\r\n       if (_isLoading != value) {\r\n         _isLoading = value;\r\n         notifyListeners();\r\n       }\r\n    });\r\n  }\r\n\r\n  Future<void> _loadTokensFromStorage() async {\r\n    await _setLoading(true);\r\n    try {\r\n      _accessToken = await _storageService.read(key: _accessTokenKey);\r\n      _idToken = await _storageService.read(key: _idTokenKey);\r\n      _refreshToken = await _storageService.read(key: _refreshTokenKey);\r\n      final expirationString = await _storageService.read(key: _accessTokenExpirationKey);\r\n\r\n      if (_accessToken != null && expirationString != null) {\r\n        _accessTokenExpiration = DateTime.tryParse(expirationString);\r\n        if (_accessTokenExpiration != null && _accessTokenExpiration!.isAfter(DateTime.now())) {\r\n          _isAuthenticated = true;\r\n          _decodeIdToken(); // Decode claims if ID token exists\r\n        } else {\r\n          // Access token expired, potentially try refresh or clear\r\n          print('Access token expired');\r\n          await clearTokens(); // Or implement refresh logic here\r\n        }\r\n      } else {\r\n        _isAuthenticated = false;\r\n      }\r\n    } catch (e) {\r\n      print(\"Error loading tokens: $e\");\r\n      _isAuthenticated = false;\r\n      await clearTokens(); // Clear potentially corrupted state\r\n    } finally {\r\n      await _setLoading(false);\r\n      notifyListeners(); // Notify listeners about the auth state\r\n    }\r\n  }\r\n\r\n  Future<void> login() async {\r\n    await _setLoading(true);\r\n    try {\r\n      final AuthorizationTokenResponse? result =\r\n          await _appAuth.authorizeAndExchangeCode(\r\n        AuthorizationTokenRequest(\r\n          AuthConfig.clientId,\r\n          AuthConfig.redirectUri,\r\n          issuer: AuthConfig.issuer,\r\n          scopes: AuthConfig.scopes,\r\n          // Use discovery document by default, but can specify endpoints:\r\n          // serviceConfiguration: AuthorizationServiceConfiguration(\r\n          //   authorizationEndpoint: AuthConfig.authorizationEndpoint, // Get from discovery or define\r\n          //   tokenEndpoint: AuthConfig.tokenEndpoint,\r\n          //   endSessionEndpoint: AuthConfig.endSessionEndpoint\r\n          // ),\r\n          preferEphemeralSession: false, // Set to true to not store cookies in browser\r\n          additionalParameters: AuthConfig.customParameters, // Pass audience here if needed\r\n        ),\r\n      );\r\n\r\n      if (result != null) {\r\n        _accessToken = result.accessToken;\r\n        _idToken = result.idToken;\r\n        _refreshToken = result.refreshToken;\r\n        _accessTokenExpiration = result.accessTokenExpirationDateTime;\r\n        _isAuthenticated = true;\r\n\r\n        await _storeTokens();\r\n        _decodeIdToken();\r\n        print('Login successful!');\r\n      } else {\r\n        print('Login failed: Authorization result is null');\r\n        _isAuthenticated = false;\r\n      }\r\n    } catch (e, s) {\r\n      print('Login Error: $e');\r\n      print('Stacktrace: $s');\r\n      _isAuthenticated = false;\r\n      await clearTokens(); // Clear any partial state on error\r\n    } finally {\r\n       await _setLoading(false);\r\n       notifyListeners();\r\n    }\r\n  }\r\n\r\n  Future<void> logout() async {\r\n     await _setLoading(true);\r\n    try {\r\n      // Use endSessionEndpoint from discovery or config\r\n      // Need the id_token to properly logout from Keycloak session\r\n      final idToken = await _storageService.read(key: _idTokenKey);\r\n      if (idToken != null) {\r\n         await _appAuth.endSession(EndSessionRequest(\r\n           idTokenHint: idToken,\r\n           issuer: AuthConfig.issuer,\r\n           postLogoutRedirectUrl: AuthConfig.redirectUri, // Redirect back to app after logout\r\n           // serviceConfiguration: provide service config if not using discovery\r\n           // additionalParameters: { 'client_id': AuthConfig.clientId } // Sometimes needed\r\n         ));\r\n      } else {\r\n         print(\"Cannot perform OIDC logout without ID Token hint.\");\r\n         // Fallback: Just clear local tokens if proper logout isn't possible\r\n      }\r\n\r\n    } catch (e, s) {\r\n      print('Logout Error: $e');\r\n      print('Stacktrace: $s');\r\n      // Even if server logout fails, clear local state\r\n    } finally {\r\n       await clearTokens(); // Always clear local tokens\r\n       await _setLoading(false);\r\n    }\r\n  }\r\n\r\n\r\n  Future<void> _storeTokens() async {\r\n    await _storageService.write(key: _accessTokenKey, value: _accessToken);\r\n    await _storageService.write(key: _idTokenKey, value: _idToken);\r\n    await _storageService.write(key: _refreshTokenKey, value: _refreshToken);\r\n    await _storageService.write(key: _accessTokenExpirationKey, value: _accessTokenExpiration?.toIso8601String());\r\n  }\r\n\r\n  Future<void> clearTokens() async {\r\n    await _storageService.delete(key: _accessTokenKey);\r\n    await _storageService.delete(key: _idTokenKey);\r\n    await _storageService.delete(key: _refreshTokenKey);\r\n    await _storageService.delete(key: _accessTokenExpirationKey);\r\n    _accessToken = null;\r\n    _idToken = null;\r\n    _refreshToken = null;\r\n    _accessTokenExpiration = null;\r\n    _idTokenClaims = null;\r\n    _isAuthenticated = false;\r\n    notifyListeners(); // Notify UI about logout\r\n  }\r\n\r\n  void _decodeIdToken() {\r\n    if (_idToken != null) {\r\n      try {\r\n        _idTokenClaims = JwtDecoder.decode(_idToken!);\r\n        print(\"Decoded ID Token: $_idTokenClaims\");\r\n      } catch (e) {\r\n        print(\"Error decoding ID token: $e\");\r\n        _idTokenClaims = null;\r\n      }\r\n    } else {\r\n      _idTokenClaims = null;\r\n    }\r\n  }\r\n\r\n  // --- Role Checks (similar to Angular) ---\r\n  List<String> _getRoles() {\r\n    if (_idTokenClaims == null) return [];\r\n\r\n    // Adjust based on your Keycloak token structure\r\n    // It's often in 'realm_access' > 'roles' or 'resource_access' > 'your_client_id' > 'roles'\r\n    final realmAccess = _idTokenClaims!['realm_access'];\r\n    if (realmAccess is Map && realmAccess['roles'] is List) {\r\n      return List<String>.from(realmAccess['roles']);\r\n    }\r\n    // Check resource access if needed\r\n    // final resourceAccess = _idTokenClaims!['resource_access'];\r\n    // if (resourceAccess is Map && resourceAccess[AuthConfig.clientId] is Map) {\r\n    //   final clientRoles = resourceAccess[AuthConfig.clientId]['roles'];\r\n    //   if (clientRoles is List) {\r\n    //      return List<String>.from(clientRoles);\r\n    //   }\r\n    // }\r\n\r\n    return [];\r\n  }\r\n\r\n  bool isSuperAdmin() {\r\n    return _getRoles().any((role) => role.toUpperCase() == 'SUPER-ADMIN');\r\n  }\r\n\r\n  bool isAdmin() {\r\n    return _getRoles().any((role) => role.toUpperCase() == 'ADMIN');\r\n  }\r\n\r\n  bool isUser() {\r\n    // Assuming 'USER' might be a default role or explicitly assigned\r\n    return _getRoles().any((role) => role.toUpperCase() == 'USER');\r\n  }\r\n\r\n  // --- TODO: Implement Token Refresh ---\r\n  // You'll need logic to use the _refreshToken to get a new _accessToken\r\n  // when the current one is about to expire or has expired.\r\n  // `flutter_appauth` has a `token` method for this:\r\n  // await _appAuth.token(TokenRequest(...));\r\n}\r\n"
        }
    ]
}